"use strict";(self.webpackChunklisk_docs=self.webpackChunklisk_docs||[]).push([[8029],{5736:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var s=n(5893),i=n(1151);const a={title:"...with Tellor",slug:"/building-on-lisk/use-oracle-data/tellor",description:"A guide on using Redstone Data Feeds to access real-world data such as asset prices, directly from your smart contracts on the Lisk testnet.",keywords:["Oracle Oracles","Redstone","price feeds","data feeds","smart contract","Lisk blockchain","Lisk network","Lisk testnet","Lisk test network","app development","dapp development","build a dapp on Lisk","build on Lisk"]},r="Using oracle data with Tellor",o={id:"building-on-lisk/using-oracle-data/tellor",title:"...with Tellor",description:"A guide on using Redstone Data Feeds to access real-world data such as asset prices, directly from your smart contracts on the Lisk testnet.",source:"@site/docs/building-on-lisk/using-oracle-data/tellor.md",sourceDirName:"building-on-lisk/using-oracle-data",slug:"/building-on-lisk/use-oracle-data/tellor",permalink:"/lisk-documentation/building-on-lisk/use-oracle-data/tellor",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"...with Tellor",slug:"/building-on-lisk/use-oracle-data/tellor",description:"A guide on using Redstone Data Feeds to access real-world data such as asset prices, directly from your smart contracts on the Lisk testnet.",keywords:["Oracle Oracles","Redstone","price feeds","data feeds","smart contract","Lisk blockchain","Lisk network","Lisk testnet","Lisk test network","app development","dapp development","build a dapp on Lisk","build on Lisk"]},sidebar:"documentationSidebar",previous:{title:"...with Redstone (Pull)",permalink:"/lisk-documentation/building-on-lisk/use-oracle-data/redstone-pull"},next:{title:"API Providers",permalink:"/lisk-documentation/lisk-tools/api-providers"}},l={},c=[{value:"Installation",id:"installation",level:2},{value:"Import",id:"import",level:2},{value:"Reading data",id:"reading-data",level:2},{value:"Deploying on Lisk",id:"deploying-on-lisk",level:2},{value:"Further resources",id:"further-resources",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",section:"section",sup:"sup",ul:"ul",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"using-oracle-data-with-tellor",children:"Using oracle data with Tellor"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"https://tellor.io/",children:"Tellor"})," is an immutable decentralized oracle protocol where parties can request the value of an off-chain data point (e.g. ETH/USD, LSK/USD) and reporters compete to add this value to an on-chain data-bank.\nThe inputs to this data-bank are secured by a network of staked reporters."]}),"\n",(0,s.jsx)(t.p,{children:"Tellor utilizes crypto-economic incentive mechanisms, rewarding honest data submissions by reporters and punishing bad actors through the issuance of Tellor\u2019s token, Tributes (TRB) and a dispute mechanism."}),"\n",(0,s.jsx)(t.p,{children:"This incentivizes an open, permissionless network of data reporting and data validation, ensuring that data can be provided by anyone and checked by everyone."}),"\n",(0,s.jsx)(t.h2,{id:"installation",children:"Installation"}),"\n",(0,s.jsx)(t.p,{children:"The first thing you'll want to do is install the basic tools necessary for using Tellor as your oracle."}),"\n",(0,s.jsxs)(t.p,{children:["To install ",(0,s.jsx)(t.a,{href:"https://github.com/tellor-io/usingtellor",children:"usingtellor"}),", run one the following commands:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Hardhat: ",(0,s.jsx)(t.code,{children:"npm install usingtellor"})]}),"\n",(0,s.jsxs)(t.li,{children:["Foundry: ",(0,s.jsx)(t.code,{children:"forge install tellor-io/usingtellor"})]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Once installed this will allow your contracts to inherit the functions from the contract 'UsingTellor'."}),"\n",(0,s.jsx)(t.p,{children:"Great! Now that you've got the tools ready, let's go through a simple exercise where we retrieve the eth/usd and lsk/usd prices from Tellor."}),"\n",(0,s.jsx)(t.h2,{id:"import",children:"Import"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:'pragma solidity >=0.8.0;\n\nimport "usingtellor/contracts/UsingTellor.sol";\n/**\n     * Network: Lisk Mainnet\n     * Address: 0x896419Ed2E0dC848a1f7d2814F4e5Df4b9B9bFcc\n*/\ncontract MyContract is UsingTellor {\n\n  constructor(address payable _tellorOracle) UsingTellor(_tellorOracle) {\n\n  }\n\n  // ...\n\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["To import the UsingTellor contract into your Solidity file, pass the desired Tellor Oracle address as a parameter.\nFor the Lisk Mainnet, the Tellor Oracle address is: ",(0,s.jsx)(t.a,{href:"https://blockscout.lisk.com/address/0x896419Ed2E0dC848a1f7d2814F4e5Df4b9B9bFcc",children:"0x896419Ed2E0dC848a1f7d2814F4e5Df4b9B9bFcc"})]}),"\n",(0,s.jsx)(t.h2,{id:"reading-data",children:"Reading data"}),"\n",(0,s.jsx)(t.p,{children:"In the example below, we add two functions:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"getETHPrice()"})," that reads the ETH/USD price feed and another function"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"getLSKPrice()"})," that reads the LSK/USD price feed from the Oracle"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:'// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport { UsingTellor } from "usingtellor/contracts/UsingTellor.sol";\n\ncontract MyContract is UsingTellor {\n\n    uint256 public ethLastStoredTimestamp;\n    uint256 public ethLastStoredPrice;\n    uint256 public lskLastStoredTimestamp;\n    uint256 public lskLastStoredPrice;\n    bytes32 public immutable ethQueryId;\n    bytes32 public immutable lskQueryId;\n    uint256 public constant DISPUTE_BUFFER = 20 minutes;\n    uint256 public constant STALENESS_AGE = 12 hours;\n\n    error StalePrice(uint256 price, uint256 timestamp);\n    error NoValueRetrieved(uint256 timestamp);\n\n    /** \n     * @dev the constructor sets the Tellor address and the ETH and LSK queryIds\n     * @param _tellorOracle is the address of the Tellor oracle\n     */\n    constructor (address payable _tellorOracle) UsingTellor(_tellorOracle) {\n        // set the ETH queryId\n        bytes memory _ethQueryData = abi.encode("SpotPrice", abi.encode("eth", "usd"));\n        ethQueryId = keccak256(_ethQueryData);\n        // set the LSK queryId\n        bytes memory _lskQueryData = abi.encode("SpotPrice", abi.encode("lsk", "usd"));\n        lskQueryId = keccak256(_lskQueryData);\n    }\n\n    /** \n     * @dev Allows a user contract to read the ETH price from Tellor and perform some \n     * best practice checks on the retrieved data\n     * @return _value the ETH spot price from Tellor, with 18 decimal places\n     * @return timestamp the value\'s timestamp\n     */\n    function getETHPrice()\n        public\n        returns (\n            uint256 _value,\n            uint256 timestamp\n        )\n    {\n        // retrieve the most recent 20+ minute old ETH price. \n        // the buffer allows time for a bad value to be disputed\n        (bytes memory _data, uint256 _timestamp) = getDataBefore(ethQueryId, block.timestamp - DISPUTE_BUFFER);\n\n        // check whether any value was retrieved\n        if (_timestamp == 0 || _data.length == 0) revert NoValueRetrieved(_timestamp);\n\n        // decode the value from bytes to uint256\n        _value = abi.decode(_data, (uint256));\n\n        // prevent a back-in-time dispute attack by caching the most recent value and timestamp.\n        // this stops an attacker from disputing tellor values to manupulate which price is used \n        // by your protocol\n        if (_timestamp > ethLastStoredTimestamp) {\n            // if the new value is newer than the last stored value, update the cache\n            ethLastStoredTimestamp = _timestamp;\n            ethLastStoredPrice = _value;\n        } else {\n            // if the new value is older than the last stored value, use the cached value\n            _value = ethLastStoredPrice;\n            _timestamp = ethLastStoredTimestamp;\n        }\n\n        // check whether value is too old\n        if (block.timestamp - _timestamp > STALENESS_AGE) revert StalePrice(_value, _timestamp);\n\n        // return the value and timestamp\n        return (_value, _timestamp);\n    }\n\n    /** \n     * @dev Allows a user contract to read the LSK price from Tellor and perform some \n     * best practice checks on the retrieved data\n     * @return _value the LSK spot price from Tellor, with 18 decimal places\n     * @return timestamp the value\'s timestamp\n     */\n    function getLSKPrice()\n        public\n        returns (\n            uint256 _value,\n            uint256 timestamp\n        )\n    {\n        (bytes memory _data, uint256 _timestamp) = getDataBefore(lskQueryId, block.timestamp - DISPUTE_BUFFER);\n\n        if (_timestamp == 0 || _data.length == 0) revert NoValueRetrieved(_timestamp);\n\n        _value = abi.decode(_data, (uint256));\n\n        if (_timestamp > lskLastStoredTimestamp) {\n            lskLastStoredTimestamp = _timestamp;\n            lskLastStoredPrice = _value;\n        } else {\n            _value = lskLastStoredPrice;\n            _timestamp = lskLastStoredTimestamp;\n        }\n\n        if (block.timestamp - _timestamp > STALENESS_AGE) revert StalePrice(_value, _timestamp);\n\n        return (_value, _timestamp);\n    }\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["You can adapt this contract to your needs.\nThe example utilizes some best practices",(0,s.jsx)(t.sup,{children:(0,s.jsx)(t.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})," for using Tellor by implementing a dispute time buffer and a data staleness check.\nIn addition, it also seeks to mitigate back-in-time dispute attacks by caching the most recent value and timestamp."]}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsxs)(t.p,{children:["For a general overview of best practices using Tellor, go to the ",(0,s.jsx)(t.a,{href:"https://docs.tellor.io/tellor/getting-data/user-checklists",children:"User checklists"})," in the Tellor docs."]})}),"\n",(0,s.jsx)(t.h2,{id:"deploying-on-lisk",children:"Deploying on Lisk"}),"\n",(0,s.jsx)(t.p,{children:"To deploy the smart contract on Lisk Sepolia or Lisk Mainnet, follow the guides"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"/lisk-documentation/building-on-lisk/deploying-smart-contract/with-Hardhat",children:"Deploying a smart contract with Hardhat"}),", or"]}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"/lisk-documentation/building-on-lisk/deploying-smart-contract/with-Foundry",children:"Deploying a smart contract with Foundry"})}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"further-resources",children:"Further resources"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["For a more robust implementation of the Tellor oracle, check out the full list of available functions ",(0,s.jsx)(t.a,{href:"https://github.com/tellor-io/usingtellor/blob/master/README.md",children:"here"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["Have a specific Data Feed Request? ",(0,s.jsx)(t.a,{href:"https://github.com/tellor-io/dataSpecs/issues/new?assignees=&labels=&template=new_query_type.yaml&title=%5BNew+Data+Request+Form%5D%3A+",children:"Fill out this form"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["Still have question? Reach out to the Tellor team on Discord ",(0,s.jsx)(t.a,{href:"https://discord.gg/tellor",children:"here"}),"."]}),"\n"]}),"\n","\n",(0,s.jsxs)(t.section,{"data-footnotes":!0,className:"footnotes",children:[(0,s.jsx)(t.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{id:"user-content-fn-1",children:["\n",(0,s.jsxs)(t.p,{children:["Based on  examples in ",(0,s.jsx)(t.a,{href:"https://github.com/tellor-io/best-practices-user/tree/main",children:"Tellors best practices repository"})," ",(0,s.jsx)(t.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>r});var s=n(7294);const i={},a=s.createContext(i);function r(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);