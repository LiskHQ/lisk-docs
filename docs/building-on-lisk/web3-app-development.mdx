---
title: Web3 app development
description: 'An introduction into Web3 application development on Lisk.'
keywords:
  [
    'Lisk',
    'Web3 apps',
    'Web3 app',
    'Web3 application',
    'Web3 app development',
    'Web3 mobile app',
    'Web3 PWA',
    'dApp development',
    'Mobile dApp development',
    'Mobile app development',
    'Lisk apps',
    'Lisk dApps',
  ]
toc_max_heading_level: 4
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Web3 app development

On this page, you will learn what Web3 applications are, how they differ from Web 2.0 apps, and how to get started with Web3 app development on Lisk.

## What are Web3 applications?

### Evolution of the Web

Since the internet was born, there has been constant innovation in how people use the internet to communicate and interact with each other.
To describe important steps in this innovation, websites, and apps are generally categorized into different Web "versions":

<Tabs queryString="web-version">
  <TabItem value="web1" label="Web 1.0">
    Web 1.0 is the first "version" of the Web, i.e., the first generation of websites that occurred when the Internet became available to the broader public around 1990.
    Web 1.0 is often referred to as the "static" or "read-only" web, consisting mainly of simple static HTML pages with limited interactivity.

    However, some Web 2.0 capabilities were present in the days of Web 1.0 but were implemented differently.
    For example, a Web 1.0 site may have had a guestbook page for visitor comments, instead of a comment section at the end of each page (typical of Web 2.0). 

  </TabItem>
  <TabItem value="web2" label="Web 2.0">
    In the late 1990s the transition to [Web 2.0](https://en.wikipedia.org/wiki/Web_2.0) started, when some Web 1.0 sites introduced dynamic HTML with social features, allowing users to interact with web pages in a much more fluent way. 

    :::info
    The term "Web 2.0" was coined by Darcy DiNucci, an information architecture consultant, in her January 1999 article [Fragmented Future](http://darcyd.com/fragmented_future.pdf).
    :::

    Web 2.0 is the era where social media, [web applications](https://en.wikipedia.org/wiki/Web_application), and mobile apps came to the rise.
    Because of the new social features and improved user experience that Web 2.0 apps offered, the number of users interacting with the web increased significantly, leading to the creation of many new web services and applications.
    Some of the most popular examples of Web 2.0 applications are Facebook, X, Amazon, and YouTube.

    Many of these applications and services became important pillars of the internet and people's lives, and even society as a whole.
    However, the more relevant these applications became, the more obvious and relevant their limitations became, as users had to trust the companies behind them with their data and privacy.

    ##### Web 2.0 limitations

    Though Web 2.0 revolutionized how people positively used the web, a few of its characteristics led to certain disadvantages for users interacting with Web2 applications. For example:

    - Censorship
    - Lack of transparency
    - Limited privacy  
    - Limited interoperability
  </TabItem>
  <TabItem value="web3" label="Web3" default>
    Web3 (also known as Web 3.0) is the next step in the evolution of the Web, aiming to address the [limitations of Web 2.0](web3-app-development?web-version=web2#web-20-limitations).
    Web3 is based on the idea of a decentralized internet, where users are in control over their data.

    :::info
    The term "Web3" was coined by Polkadot founder and Ethereum co-founder Gavin Wood in 2014, referring to a [decentralized online ecosystem based on the blockchain](https://www.wired.com/story/web3-gavin-wood-interview/).
    :::

    2015 marked the beginning of the Web3 era when Ethereum launched as the world's first programmable blockchain.
    Web3 applications are decentralized applications (also known as "dApps") that run on a blockchain, allowing users to interact with each other and the blockchain in a trustless way.
    This puts users in control of their data and privacy, removing the need to trust a central authority.

    Web3 apps are built on top of blockchain technology, which allows users greater ownership and control over their data.
    This provides new features and allows services that are not feasible in the Web2 world.
    Often, Web3 apps combine other cutting-edge technologies like AI to provide unique and new user experiences.

    New types of Web3 apps include:
    
    - DeFi (Decentralized Finance), for example:
      - DEXs (Decentralized Exchanges)
      - GameFi (Gaming Finance)
      - Staking and yield farming platforms
      - Decentralized crowdfunding and investing platforms
      - Decentralized lending and borrowing
      - Prediction markets
      - Asset / RWA tokenization platforms
    - DAOs (Decentralized Autonomous Organizations)
    - [DeSoc](https://onchain.org/magazine/decentralized-social-media-business-opportunities-are-they-real/) (Decentralized Social Media)
    - [DeSci](https://onchain.org/magazine/not-only-the-best-desci-crypto-projects-an-overview/) (Decentralized Science)
    - [DePIN](https://onchain.org/magazine/how-depin-web3-projects-are-connecting-the-world-to-crypto/) (Decentralized Physical Infrastructure Networks)
  
    Web3 is a promise to bring back the original vision of the internet, where users are in control of their data and privacy, and where the internet is a place for free speech and innovation.
    However, how blockchain technology is implemented and used in apps can vary greatly, and not all Web3 apps are equally decentralized and trustless.
  </TabItem>
</Tabs>

### Further reading
- [Introduction to Web3](https://ethereum.org/en/web3/) *by Ethereum*

## Getting started with Web3 app development

### Platforms

To get started with the actual development of a Web3 app, you need to be clear about the right **platform(s)** to build your Web3 app on.
The following sections will give you an overview of the different platforms you can choose from to build your Web3 app on, including further resources and guides to get you started with the app development.

<Tabs queryString="platform">
  <TabItem value="mobile" label="Web3 Mobile Apps">
Mobile applications are generally a great way to reach a large audience, as most people have a smartphone and use it to access the internet.
Mobile apps can use the integrated features of handheld devices and are typically faster and more user-friendly than websites.
This can provide a more immersive experience for users.
Last but not least, mobile apps allow users to access your app on the go, which can be a big advantage for many use cases.

##### Guides
- [Build Web3 Mobile Apps with React Native on Lisk with thirdweb](https://blog.thirdweb.com/web3-mobile-apps/build-web3-mobile-apps-with-reactive-native-on-lisk/)
- [Video tutorial: How to Build a Web3 Mobile App](https://www.youtube.com/watch?v=PRAsc_ocVtk) *by thirdweb*
- [Building a mobile dApp with Flutter](https://medium.com/dash-community/building-a-mobile-dapp-with-flutter-be945c80315a)
</TabItem>
<TabItem value="web" label="Web3 Web Apps">
The main advantage of web applications is that they are platform-independent and can be accessed from any device with a web browser.
Additionally, they don't need to be installed by the user and can be used directly in the browser.

##### Guides
- [How to Build an NFT Minting dApp](https://blog.thirdweb.com/guides/build-nft-minting-dapp-with-thirdweb-guide/) *by thirdweb*
</TabItem>
<TabItem value="pwa" label="Web3 PWAs">
A Progressive Web App (PWA) allows users to install a web app on their devices.
They appear as native apps on desktop or mobile devices and offer features like offline support and push notifications.
This way, PWAs allow the development of an application that can be used via a browser[^1], mobile, or desktop application alike.
Therefore, PWAs are a great choice for reaching users on different platforms simultaneously.

Additionally, PWAs allow a user to directly install the app through your web app without the need to visit an app store.
This allows you to serve the app directly to the users, without bothering about restrictions of app stores on what is allowed for blockchain applications.
In-app purchase fees can also be avoided because users no longer need to go through the app store.

[^1]: Only supported in PWA-compatible browsers (most Chromium-based browsers should work).

##### Guides
- [How to Create a Web3 PWA](https://blog.thirdweb.com/guides/how-to-create-a-web3-pwa/) *by thirdweb*
- [Video tutorial: Build a Web3 PWA](https://www.youtube.com/watch?v=VU8i-dn2_GE) *by thirdweb*
</TabItem>
{/* ### Web3 Desktop apps
Desktop apps are native applications that are installed on a user's computer.
Similar to mobile apps, they are platform dependent.
Desktop apps make it difficult for users to access them on the go, as you need a computer to use them.
On the other side, desktop apps shine with their performance and the ability to use the full power of the computer they are running on, and they are typically build for larger screens allowing more complex user interfaces.
So if you application requires a lot of computing power, and/or a very complex UI that might not be fitting for a mobile screen, a desktop app can be the right choice.
 */}
</Tabs>

### Onboarding Web2 users to Web3

A significant challenge for Web3 applications is delivering a user experience that is as seamless as what users expect from Web2 applications.

To onboard Web2 users to Web3, apps need to simplify user interaction so that it feels natural and intuitive to them while still providing the benefits of Web3 in a secure way.
To aim for a smooth user experience, and to abstract the complexity of blockchain technology away from the user, it is highly recommended to include "account abstraction" (sometimes also referred to as "smart accounts", "smart wallets" or "smart contract accounts") into your Web3 application.

#### Account Abstraction and Smart Accounts

Account abstraction is a concept that introduces an additional layer over the blockchain, which delegates most of the complexity of interacting with the blockchain away from the user to smart contracts.
It has the potential to significantly enhance the user experience of Web3 applications, as it allows users to interact with the app in a more user-friendly and secure way.
Account abstraction is also sometimes referred to as "smart accounts" or "smart wallets", because it puts most of the logic of handling transactions and user interactions into smart contracts.

This unlocks a range of features that significantly enhance user experience:

- **Signature Abstraction**: Users no longer need to manually sign transactions with private keys.
Instead, smart contracts handle the signing logic, eliminating the risk of user error and phishing attacks.
- **Enhanced Security**: Multi-signature wallets, social recovery mechanisms, and custom access controls can be implemented within the smart contract, mitigating single points of failure and theft risks.
- **Customizable Transactions**: Smart contracts can be programmed to include spending limits, time-locked transactions, and dApp-specific controls.
This allows to automate transactions and tailoring the user experience to specific needs.
- **Fee Abstraction**: Transaction fees can be dynamically managed through smart contracts, enabling features like custom gas tokens and gasless transactions for specific use cases.

On the technical side, account abstraction is implemented by the [ERC-4337 standard](https://eips.ethereum.org/EIPS/eip-4337), which defines a set of interfaces and functions that smart contracts can use to interact with the blockchain on behalf of users.

It comprises the following fundamental components:

- **UserOperation**: A structure that describes a transaction to be sent on behalf of a user.
To avoid confusion, it is not named “transaction”.
Like a transaction, it contains `sender`, `to`, `calldata`, `maxFeePerGas`, `maxPriorityFee`, `signature`, `nonce`.
Unlike a transaction, the use of the `signature` field is not defined by the protocol but by each account implementation.
Also, it contains several other fields, described in detail in ERC-4337.
- **Account Contract**: The user's smart account sending a user operation.
- **EntryPoint**: A singleton contract to validate and execute bundles of UserOperations.
It manages the verification and execution logic for UserOperations, ensuring they are processed correctly.
- **Bundler**: Bundlers are contracts that package UserOperations from a mempool and send them to the EntryPoint.
Bundling is the process where a node/bundler collects multiple UserOperations and creates a single transaction to submit onchain.
- **Account Factory**: When using a wallet for the first time, this contract specifies the creation of the smart contract wallet.
- **Paymaster**(optional): a helper contract that agrees to pay for the transaction, instead of the sender itself.
Paymasters can cover gas costs for users, sponsor specific transactions, or implement custom fee models, opening doors for novel use cases.

##### Further reading
- [Account abstraction: A complete overview](https://blaize.tech/blog/account-abstraction-guide/) *by Blaize*
- [What is Account Abstraction (ERC-4337)?](https://www.alchemy.com/overviews/what-is-account-abstraction) *by Alchemy*
- [What is Account Abstraction? ERC-4337 Explained](https://blog.thirdweb.com/account-abstraction-erc4337/) *by thirdweb*
- [How to pay gas fees with LSK](https://blog.thirdweb.com/changelog/ts-tokenpaymasters-pay-for-gas-with-lisk-lsk-base-usdc-or-celo-cusd/) *by thirdweb*
- [How to create a Web3 mobile app with gasless transactions on Lisk](https://blog.thirdweb.com/web3-mobile-apps/build-web3-mobile-apps-with-reactive-native-on-lisk/) *by thirdweb*

{/* TODO: Extend with additional topics relevant for web3 devs
### Best Practices & other Considerations

- Proxy contracts: 
Smart contracts are immutable, meaning that once they are deployed, they cannot be changed.
However, to fix bugs or add new features to an already deployed smart contract, proxy contracts can be used to upgrade smart contracts without changing the contract address.
- Gas Optimization:
- secure key management
- Bug bounty programs
- handling user data */}

### Testing and deployment
When it comes to testing and deployment of Web3 apps, there are some additional aspects to consider compared to Web2 apps.
The intrinsic vulnerabilities of smart contracts, the immutability of blockchain data, and the interactions with a decentralized network, call for specific testing and security measures.
Gladly, many tools are already available to help developers ensure the security and reliability of their Web3 apps.
The list below provides a selection of popular tools and services used to test Web3 apps:

#### Smart contract test suites
Often, smart contract development frameworks come with built-in testing tools that simplify to create comprehensive tests for smart contracts.
This includes utilities to simplify writing of the tests, or the ability to spin up a local node for deploying and testing smart contracts in a local development network, i.e. Devnet.

A selection of popular testing environments for smart contracts can be found below:

- [Foundry](https://book.getfoundry.sh/): Foundry is a smart contract development toolchain.
Foundry provides a robust [testing framework](https://book.getfoundry.sh/forge/tests) that allows developers to create comprehensive test suites for their projects using Solidity.
The [Forge Standard Library](https://book.getfoundry.sh/reference/forge-std/) provides a set of utilities to simplify testing smart contracts.
It also provides a local testnet node for deploying and testing smart contracts, see [Anvil](https://book.getfoundry.sh/anvil/).
- [Hardhat](https://hardhat.org): Hardhat is a development environment that facilitates smart contract development.
It comes built-in with [Hardhat Network](https://hardhat.org/hardhat-network/docs/overview), a local Ethereum network node designed for development.
Hardhat allows you to deploy your contracts, [run your tests](https://hardhat.org/tutorial/testing-contracts), and debug your code, all within the confines of your local machine.
Tests are written in JavaScript, using [ethers](https://ethers.org/).
- [Remix](https://remix.ethereum.org/): Remix is an IDE that helps you write Solidity contracts straight from the browser.
It provides powerful features for testing and debugging smart contracts, like the [Debugger](https://remix-ide.readthedocs.io/en/latest/debugger.html) or the [Unit Testing Plugin](https://remix-ide.readthedocs.io/en/latest/unittesting.html).
- [Waffle](https://getwaffle.io/): Waffle is another framework for developing and testing smart contracts.
Tests are written in JavaScript / Typescript.

##### Guides
- [Deploying a smart contract with Foundry](/building-on-lisk/deploying-smart-contract/with-Foundry#testing-the-smart-contract)
- [Deploying a smart contract with Hardhat](/building-on-lisk/deploying-smart-contract/with-Hardhat.md)
- [Deploying a smart contract with Remix](/building-on-lisk/deploying-smart-contract/with-Remix.mdx)

#### Smart contract code analysis
To ensure the security of smart contracts, it is essential to analyze the code for vulnerabilities.
There are several tools available that help developers to analyze their smart contracts for common security issues and vulnerabilities, for example:

- [Slither](https://github.com/crytic/slither): Slither is a Solidity static analysis framework that detects common vulnerabilities in smart contracts.
- [Etheno](https://github.com/crytic/etheno): Etheno is a tool that helps developers write secure smart contracts by providing a set of rules that can be used to check the security of smart contracts.
- [Mythril](https://github.com/Consensys/mythril): Mythril is a security analysis tool for Ethereum smart contracts.

#### Testnets
Testnets are public blockchains that are used for testing purposes.
They often have the same features as the mainnet, but the tokens on the testnet have no real value - this allows developers to test their smart contracts and Web3 apps in a real-world environment without risking real assets.
Before deploying a smart contract to the mainnet, it is highly recommended to test it on a testnet to ensure that it works as expected.
##### Public testnets
The following testnets are available for testing smart contracts and Web3 apps on Lisk:
- [Lisk Sepolia](/about-lisk/network-info.md#lisk-sepolia-testnet)

:::tip
To get free testnet ETH and/or LSK, check out our [available faucets](/lisk-tools/faucets.md).
:::

##### Virtual testnets
[Tenderly](https://tenderly.co/) recently introduced the possibility to spin up [Virtual Testnets](https://blog.tenderly.co/how-virtual-testnets-replace-public-testnets/).
Virtual Testnets are a new way to test your Web3 apps, bringing the onchain data of a mainnet and the flexibility of a local environment together.

Some interesting features of Virtual Testnets are:

- **Build your dapps with real, up-to-date mainnet data** and test its actual performance under realistic conditions. 
- **Get an unlimited faucet** and stop begging for test ETH.
Mint both native and ERC-20 tokens in any amount you need, impersonate accounts, and test complex scenarios uninterruptedly.
- **Fully customize your development infrastructure** to fit your unique workflows.
Virtual Testnets are easy to set up and configure, giving you full control and flexibility over your environments.
You can even manipulate the state of your forked chains with custom values, custom chain IDs, and more, making sure they fit your unique requirements.

#### E2E testing
End-to-end (E2E) testing is a type of software testing that tests the complete flow of an application from start to finish.
This specifically includes testing the frontend of your application, which ensures that the user interface works as expected.
To deal with stuff like wallets, and other Web3-specific things, you might want to use specialized Web3 E2E testing tools.

[Synpress](https://synpress.io/) is an E2E testing library for Web3 dapps. 
Synpress can be used with two leading E2E testing frameworks out there, i.e., [Playwright](https://playwright.dev/) and [Cypress](https://www.cypress.io/), with support for all of their features.

#### Performance testing
Performance testing is essential to ensure that your Web3 app can handle the expected load of users and their interactions.
Measure and improve your app's performance, throughput, and resilience under different levels of traffic and transactions.

Some examples of performance testing tools are:

- [k6](https://k6.io/)
- [Artillery](https://www.artillery.io/)

{/* #### Automated Testing and Continuous Integration (CI) */}

#### Monitoring
Monitoring is important to ensure that your Web3 app is running smoothly and to detect and fix issues before they affect your users.

Some popular monitoring tools are:

- [Prometheus](https://prometheus.io/) combined with [Grafana](https://grafana.com/)
- [Elastic Stack (ELK)](https://www.elastic.co/elastic-stack)

### Web2 vs Web3 app development
#### Languages
Concerning frontend app development, there aren't many differences between Web2 and Web3 apps when it comes to programming languages.
All languages that are typically used for Web2 app development can also be used for Web3 app development.
In the end, Web3 apps can even look and feel exactly like Web2 apps for users, because their frontend is built with the same technologies.

However, the backend of Web3 apps is quite different, as it interacts with the blockchain through smart contracts.
Smart contracts are written in [Solidity](https://soliditylang.org/), therefore Web3 developers need to know Solidity to build the smart contracts they require for their app.
Luckily, for many use cases, there are already audited smart contracts available(see [OpenZeppelin](https://www.openzeppelin.com/solidity-contracts) or [thirdweb](https://thirdweb.com/explore)) that can be used, so developers don't need to write all of their smart contracts from scratch.

#### Tech stack
As mentioned above, the Web2 and Web3 app frontend development is very similar.
Theoretically, you could build a Web3 app with nearly the same tech stack as a Web2 app, like Next.js, Vite, etc.
The only thing you need to add is a way for your application to interact with the blockchain, see [Data access](#data-access).

To support developers, many blockchain platforms offer their own SDKs and tools to interact with their blockchain, which can make development easier and more efficient.
There are also SDKs for Web3 app development, like [thirdweb](https://thirdweb.com/) or [Alchemy](https://www.alchemy.com/), which take away most of the complexity of blockchain development and provide a smooth developer experience.
thirdweb supports [Lisk](https://thirdweb.com/lisk) and many other EVM-compatible blockchains.

#### Data storage
In Web2 apps, data is typically stored in a centralized database.
In Web3 apps, some data is stored on the blockchain, i.e., a decentralized database.
How the data is stored is defined inside of smart contracts.
However, it should be noted that onchain data on a public blockchain is visible to everyone and, therefore, not suitable for all types of data.
Especially sensitive and private user data should not be stored on the blockchain, except if it is encrypted.
In addition, storing large amounts of data onchain is both expensive and slow.
Therefore, Web3 apps sometimes use a combination of onchain storage and offchain storage.

#### Data access
In Web2 apps, data from the database is accessed through APIs.
In Web3 apps, blockchain data is accessed through smart contracts.
They usually expose public functions that can be called by the app frontend to read and/or write data from/to the blockchain, similar to a classical API.
To interact with the blockchain, there are various libraries and frameworks available, like [viem](https://viem.sh/), [web3.js](https://web3js.readthedocs.io), or [ethers.js](https://docs.ethers.io).
