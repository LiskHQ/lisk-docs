---
title: Lisk L1->L2 migration guide
slug: /building-on-lisk/migration-guide
description: "A migration guide, explaining how to smoothly migrate any Lisk L1 app to Lisk L2."
keywords: [
    "Lisk",
    "Lisk migration",
    "Lisk L1",
    "Lisk L2",
    "Lisk testnet",
    "Lisk SDK",
    "Solidity",
    "smart contract development",
    "build on lisk",
    ]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Lisk L1->L2 migration guide

How to smoothly migrate any Lisk L1 app to Lisk L2.

## Requirements

You need:

- A Lisk L1 application built on [Lisk SDK](https://github.com/LiskHQ/lisk-sdk) version 6.0.0 or later.
- The smart contract development framework of your choice. 
In this guide, we will use the [Foundry](https://book.getfoundry.sh/) framework.

## Project setup

To start with the project migration, first create a new project with Foundry like this:

```bash
forge init hello_liskl2
```

This will create a new folder `hello_liskl2`, which will contain the smart contracts we are going to implement.

```bash
cd hello_liskl2
```

## Module migration

**Modules in Lisk L1 are re-implemented as smart contracts in Lisk L2.**

To create a new smart contract create a new file `Hello.sol` under `src/` and add the following content: 

```solidity title="hello_liskl2/src/Hello.sol"
// SPDX-License-Identifier: MIT
// compiler version must be greater than or equal to 0.8.20 and less than 0.9.0
pragma solidity ^0.8.20;

contract Hello {

}
```

Inside the new contract, we will put all the logic that was residing in the Lisk L1 `Hello` module before.

:::note
Depending on the complexity of your modules, it can be beneficial to split the logic into several smart contracts, too.
:::

### Table: Lisk L1/L2 comparison
| Description          | Lisk L1                      | Lisk L2                       |
| :------------------- | :----------------------------| :---------------------------- |
| Onchain business logic| Module                      |[Smart contract](https://solidity-by-example.org/first-app/) |
| Onchain data storage | Stores (onchain)             |[State variables](https://solidity-by-example.org/variables/)|
| Logging to the blockchain| Blockchain Events        |[Events](https://solidity-by-example.org/events/)|
| State-transition logic triggered by a transaction| Commands|[Functions](https://solidity-by-example.org/function/)|
| API                  | Endpoints                    |[View functions](https://solidity-by-example.org/view-and-pure-functions/)|
| Internal API         | Methods                      |[Functions (+ modifiers)](https://solidity-by-example.org/function-modifier/)|
| Logic triggered per block| Lifecycle Hooks          |X[^1]                              |

[^1]: No direct equivalent in solidity.
Please investigate for custom solutions to migrate logic residing in the lifecycle hooks.

### Storage

Migrate the onchain stores of a module by implementing corresponding state variables in the contract as shown below.

<Tabs>
  <TabItem value="liskl1" label="Lisk L1">
  <Tabs>
      <TabItem value="message" label="Message Store" default>
        ```typescript title="hello_client/src/app/modules/hello/stores/message.ts"
        import { BaseStore } from 'lisk-sdk';

        export interface MessageStoreData {
            message: string;
        }

        export const messageStoreSchema = {
            $id: '/hello/message',
            type: 'object',
            required: ['message'],
            properties: {
                message: {
                    dataType: 'string',
                    fieldNumber: 1,
                },
            },
        };

        export class MessageStore extends BaseStore<MessageStoreData> {
            public schema = messageStoreSchema;
        }
        ```
      </TabItem>
      <TabItem value="counter" label="Counter Store">
        ```typescript title="hello_client/src/app/modules/hello/stores/counter.ts"
        import { BaseStore } from 'lisk-sdk';

        export interface CounterStoreData {
          counter: number;
        }

        export const counterKey = Buffer.alloc(0);

        export const counterStoreSchema = {
          $id: '/hello/counter',
          type: 'object',
          required: ['counter'],
          properties: {
            counter: {
              dataType: 'uint32',
              fieldNumber: 1,
            },
          },
        };

        export class CounterStore extends BaseStore<CounterStoreData> {
          public schema = counterStoreSchema;
        }
        ```
      </TabItem>
    </Tabs>
  </TabItem>
  <TabItem value="liskl2" label="Lisk L2" default>
    ```solidity title="hello_liskl2/src/Hello.sol"
    // SPDX-License-Identifier: MIT
    // compiler version must be greater than or equal to 0.8.20 and less than 0.9.0
    pragma solidity ^0.8.20;

    contract Hello {
      /** State variables */
      // State variable for the Hello messages
      mapping(address => string) public message;
      // State variable for the message counter
      uint32 public counter = 0;
    }
    ```
  </TabItem>
</Tabs>

### Events

Migrate the blockchain events of a module by implementing corresponding events in the contract as shown below.

<Tabs>
  <TabItem value="liskl1" label="Lisk L1">
    
      ```typescript title="hello_client/src/app/modules/hello/events/new_hello.ts"
      import { BaseEvent } from 'lisk-sdk';

      export const newHelloEventSchema = {
        $id: '/hello/events/new_hello',
        type: 'object',
        required: ['senderAddress', 'message'],
        properties: {
          senderAddress: {
            dataType: 'bytes',
            fieldNumber: 1,
          },
          message: {
            dataType: 'string',
            fieldNumber: 2,
          },
        },
      };

      export interface NewHelloEventData {
        senderAddress: Buffer;
        message: string;
      }

      export class NewHelloEvent extends BaseEvent<NewHelloEventData> {
        public schema = newHelloEventSchema;
      }
      ```
  </TabItem>
  <TabItem value="liskl2" label="Lisk L2" default>
    ```solidity title="hello_liskl2/src/Hello.sol"
    // SPDX-License-Identifier: MIT
    // compiler version must be greater than or equal to 0.8.20 and less than 0.9.0
    pragma solidity ^0.8.20;

    contract Hello {
      /** State variables */
      // State variable for the Hello messages
      mapping(address => string) public message;
      // State variable for the message counter
      uint32 public counter = 0;
      // Event for new Hello messages
      event NewHello(address indexed sender, string message);

      /** Events */
      // Event for new Hello messages
      event NewHello(address indexed sender, string message);
    }
    ```
  </TabItem>
</Tabs>

### State transition logic

<details>
<summary>Configuration migration</summary>
#### Configuration
The module-specific configurations, which resided in the `config.json` on Lisk L1, are now part of the smart contract itself, and defined as state variables.

To edit the configuration options of the Hello module, we implement the following functions in the Hello contract:

- `setBlacklist()` to configure the blacklist of words that are not allowed in the Hello message.
- `setMinMaxMessageLength()` to configure the minimum and maximum length of the Hello message.

Add the following modifiers to the functions:

- `public` to make the function callable from outside the contract.
- `onlyOwner` to check that the caller is the owner of the contract.

:::tip
`public` is the default visibility modifier for functions in Solidity. 
`onlyOwner` is a custom modifier that we need to implement in the contract ourselves, as shown in the code example below.
:::
</details>

<details>
<summary>Verification migration</summary>
#### Verification

To verify the Hello message, we implement a custom modifier `validMessage()` in the contract.

Inside of this modifier, we check the length of the message and if it contains any blacklisted words, like it was done in the `verify()` method of the Lisk L1 Hello module.

To check the length of strings conviniently, we use the `Strings` library, which is part of the Solidity Util library.

You can add `solidity-util` to your projects dependencies by running the following command:

```bash title="hello_liskl2/"
forge install willitscale/solidity-util
```

Now import the `Strings.sol` file in the `Hello.sol` contract and add `using Strings for string;` on top of the contract.

```solidity title="hello_liskl2/src/Hello.sol"
pragma solidity ^0.8.20;
import "lib/solidity-util/lib/Strings.sol";

contract Hello {
    using Strings for string;

    // ....
}
```

Now you can conveniently check the length of strings in the `validMessage()` modifier like this:

```solidity title="hello_liskl2/src/Hello.sol"
// Modifier to check if the message is valid.
modifier validMessage(string memory _message) {
    require(_message.length() >= minlength, "Message too short");
    require(_message.length() <= maxLength, "Message too long");
    for (uint i = 0; i < blacklist.length; i++) {
        require(!_message.contains(blacklist[i]), "Message contains blacklisted word");
    }
    _;
}
```
</details>

<details>
<summary>Execution migration</summary>
#### Execution

To execute the Hello message, we implement the `createHello()` function in the contract.

Inside of this function, we save the message of the sender in the `message` mapping under the sender address.
The sender address is a global variable in Solidity and can be accessed with `msg.sender`.

Additionally, we increment the Hello message counter by +1, and emit the `NewHello` event, like it was done in the `execute()` method of the Lisk L1 Hello module previously.

The `validMessage()` modifier the we defined above in the Verification section is used to check if the message is valid before saving it to the `message` mapping.

```solidity title="hello_liskl2/src/Hello.sol"
// Function to create a new Hello message
function createHello(string calldata _message) public validMessage(_message) {
    message[msg.sender] = _message;
    counter+=1;
    emit NewHello(msg.sender, _message);
}
```

</details>
<Tabs>
  <TabItem value="liskl1" label="Lisk L1">
    ```typescript title="hello_client/src/app/modules/hello/commands/create_hello_command.ts"
    /* eslint-disable class-methods-use-this */

    import {
      BaseCommand,
      CommandVerifyContext,
      CommandExecuteContext,
      VerificationResult,
      VerifyStatus,
    } from 'lisk-sdk';
    import { createHelloSchema } from '../schema';
    import { MessageStore } from '../stores/message';
    import { counterKey, CounterStore, CounterStoreData } from '../stores/counter';
    import { ModuleConfig } from '../types';
    import { NewHelloEvent } from '../events/new_hello';

    interface Params {
      message: string;
    }

    export class CreateHelloCommand extends BaseCommand {
      public schema = createHelloSchema;
      private _blacklist!: string[];

      // eslint-disable-next-line @typescript-eslint/require-await
      public async init(config: ModuleConfig): Promise<void> {
        // Set _blacklist to the value of the blacklist defined in the module config
        this._blacklist = config.blacklist;
        // Set the max message length to the value defined in the module config
        this.schema.properties.message.maxLength = config.maxMessageLength;
        // Set the min message length to the value defined in the module config
        this.schema.properties.message.minLength = config.minMessageLength;
      }

      // eslint-disable-next-line @typescript-eslint/require-await
      public async verify(context: CommandVerifyContext<Params>): Promise<VerificationResult> {
        let validation: VerificationResult;
        const wordList = context.params.message.split(" ");
        const found = this._blacklist.filter(value => wordList.includes(value));
        if (found.length > 0) {
          context.logger.info("==== FOUND: Message contains a blacklisted word ====");
          throw new Error(
              `Illegal word in hello message: ${  found.toString()}`
            );
        } else {
          context.logger.info("==== NOT FOUND: Message contains no blacklisted words ====");
          validation = {
            status: VerifyStatus.OK
          };
        }
        return validation;
      }

      public async execute(context: CommandExecuteContext<Params>): Promise<void> {
        // 1. Get account data of the sender of the Hello transaction.
        const { senderAddress } = context.transaction;
        // 2. Get message and counter stores.
        const messageSubstore = this.stores.get(MessageStore);
        const counterSubstore = this.stores.get(CounterStore);

        // 3. Save the Hello message to the message store, using the senderAddress as key, and the message as value.
        await messageSubstore.set(context, senderAddress, {
          message: context.params.message,
        });

        // 3. Get the Hello counter from the counter store.
        let helloCounter: CounterStoreData;
        try {
          helloCounter = await counterSubstore.get(context, counterKey);
        } catch (error) {
          helloCounter = {
            counter: 0,
          }
        }
        // 5. Increment the Hello counter +1.
        helloCounter.counter+=1;

        // 6. Save the Hello counter to the counter store.
        await counterSubstore.set(context, counterKey, helloCounter);

        // 7. Emit a "New Hello" event
        const newHelloEvent = this.events.get(NewHelloEvent);
        newHelloEvent.add(context, {
          senderAddress: context.transaction.senderAddress,
          message: context.params.message
        },[context.transaction.senderAddress]);
      }
    }
    ```
  </TabItem>
  <TabItem value="liskl2" label="Lisk L2" default>
   

    ```solidity title="hello_liskl2/src/Hello.sol"
    // SPDX-License-Identifier: MIT
    // compiler version must be greater than or equal to 0.8.20 and less than 0.9.0
    pragma solidity ^0.8.20;
    import "lib/solidity-util/lib/Strings.sol";

    contract Hello {
        using Strings for string;

        /** State variables */
        // State variable for the Hello messages
        mapping(address => string) public message;
        // State variable for the message counter
        uint32 public counter = 0;
        // Address of the contract owner
        address public owner;
        // Blacklist of words that are not allowed in the Hello message
        string[] public blacklist = ["word1","word2"];
        // Maximum length of the Hello message
        uint32 public maxLength = 200;
        // Minimum length of the Hello message
        uint32 public minlength = 3;

        constructor() {
            // Set the transaction sender as the owner of the contract.
            owner = msg.sender;
        }

        /** Modifiers */
        // Modifier to check that the caller is the owner of the contract.
        modifier onlyOwner() {
            require(msg.sender == owner, "Not owner");
            _;
        }
        // Modifier to check if the message is valid.
        modifier validMessage(string memory _message) {
            require(_message.length() >= minlength, "Message too short");
            require(_message.length() <= maxLength, "Message too long");
            for (uint i = 0; i < blacklist.length; i++) {
                require(!_message.contains(blacklist[i]), "Message contains blacklisted word");
            }
            _;
        }

        /** Events */
        // Event for new Hello messages
        event NewHello(address indexed sender, string message);

        /** Functions */
        // Function to configure the blacklist
        function setBlacklist(string[] calldata _newBlacklist) public onlyOwner {
            blacklist = _newBlacklist;
        }
        // Function to configure min/max message length
        function setMinMaxMessageLength(uint32 _newMin,uint32 _newMax) public onlyOwner {
            minlength = _newMin;
            maxLength = _newMax;
        }
        // Function to create a new Hello message
        function createHello(string calldata _message) public validMessage(_message) {
            message[msg.sender] = _message;
            counter+=1;
            emit NewHello(msg.sender, _message);
        }
    }
    ```
  </TabItem>
</Tabs>

### Endpoints

<Tabs>
  <TabItem value="liskl1" label="Lisk L1">
  ```typescript title="hello_client/src/app/modules/hello/endpoint.ts"
  export class HelloEndpoint extends BaseEndpoint {
    public async getHelloCounter(ctx: ModuleEndpointContext): Promise<CounterStoreData> {
      const counterSubStore = this.stores.get(CounterStore);

      const helloCounter = await counterSubStore.get(
        ctx,
        counterKey,
      );

      return helloCounter;
    }

    public async getHello(ctx: ModuleEndpointContext): Promise<MessageStoreData> {
      const messageSubStore = this.stores.get(MessageStore);

      const { address } = ctx.params;
      if (typeof address !== 'string') {
        throw new Error('Parameter address must be a string.');
      }
      cryptography.address.validateLisk32Address(address);
      const helloMessage = await messageSubStore.get(
        ctx,
        cryptography.address.getAddressFromLisk32Address(address),
      );
      return helloMessage;
    }
  }
  ```
  </TabItem>
  <TabItem value="liskl2" label="Lisk L2" default>
    ```solidity title="hello_liskl2/src/Hello.sol"
    // Function to get the Hello message counter
    function getHelloCounter() public view returns (uint32) {
        return counter;
    }
    // Function to get the Hello message of an address
    function getHello(address _address) public view returns (string) {
        return message[_address];
    }
    ```
  </TabItem>
</Tabs>

### Methods

{/* ## Plugin migration */}