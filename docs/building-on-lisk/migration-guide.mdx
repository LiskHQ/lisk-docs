---
title: L1 migration guide
slug: /building-on-lisk/migration-guide
description: "A migration guide, explaining how to smoothly migrate any Lisk L1 app to Lisk L2."
keywords: [
    "Lisk",
    "Lisk migration",
    "Lisk L1",
    "Lisk L2",
    "Lisk testnet",
    "Lisk SDK",
    "Solidity",
    "smart contract deployment",
    "build on lisk",
    ]
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# L1 migration guide

How to smoothly migrate any Lisk L1 app to Lisk L2.

## Requirements

You need:

- A Lisk L1 application built on [Lisk SDK](https://github.com/LiskHQ/lisk-sdk) version 6.0.0 or later.
- The smart contract development framework of your choice. 
In this guide, we will use the [Foundry](https://book.getfoundry.sh/) framework.

## Project setup

To start with the project migration, first create a new project with Foundry like this:

```bash
forge init hello_liskl2
```

This will create a new folder `hello_liskl2`, which will contain the smart contracts we are going to implement.

```bash
cd hello_liskl2
```

## Module migration

**Modules in Lisk L1 are re-implemented as smart contracts in Lisk L2.**

To create a new smart contract create a new file `Hello.sol` under `hello_liskl2/src/` and add the following content: 

```solidity
// SPDX-License-Identifier: MIT
// compiler version must be greater than or equal to 0.8.20 and less than 0.9.0
pragma solidity ^0.8.20;

contract Hello {

}
```

Inside the new contract, we will put all the logic that was residing in the Lisk L1 `Hello` module before.

:::note
Depending on the complexity of your modules, it can be beneficial to split the logic into several smart contracts, too.
:::

### Table: Lisk L1/L2 comparison
| Description          | Lisk L1                      | Lisk L2                       |
| :------------------- | :----------------------------| :---------------------------- |
| Onchain business logic| Module                      |[Smart contract](https://solidity-by-example.org/first-app/) |
| Onchain data storage | Stores (onchain)             |[State variables](https://solidity-by-example.org/variables/)|
| Logging to the blockchain| Blockchain Events        |[Events](https://solidity-by-example.org/events/)|
| State-transition logic triggered by a transaction| Commands|[Functions](https://solidity-by-example.org/function/)|
| API                  | Endpoints                    |[View functions](https://solidity-by-example.org/view-and-pure-functions/)|
| Internal API         | Methods                      |[Functions (+ modifiers)](https://solidity-by-example.org/function-modifier/)|
| Logic triggered per block| Lifecycle Hooks          |X                              |

### Storage

<Tabs>
  <TabItem value="liskl1" label="Lisk L1">
  <Tabs>
      <TabItem value="message" label="Message Store" default>
        ```typescript
        import { BaseStore } from 'lisk-sdk';

        export interface MessageStoreData {
            message: string;
        }

        export const messageStoreSchema = {
            $id: '/hello/message',
            type: 'object',
            required: ['message'],
            properties: {
                message: {
                    dataType: 'string',
                    fieldNumber: 1,
                },
            },
        };

        export class MessageStore extends BaseStore<MessageStoreData> {
            public schema = messageStoreSchema;
        }
        ```
      </TabItem>
      <TabItem value="counter" label="Counter Store">
        ```typescript
        import { BaseStore } from 'lisk-sdk';

        export interface CounterStoreData {
          counter: number;
        }

        export const counterKey = Buffer.alloc(0);

        export const counterStoreSchema = {
          $id: '/hello/counter',
          type: 'object',
          required: ['counter'],
          properties: {
            counter: {
              dataType: 'uint32',
              fieldNumber: 1,
            },
          },
        };

        export class CounterStore extends BaseStore<CounterStoreData> {
          public schema = counterStoreSchema;
        }
        ```
      </TabItem>
    </Tabs>
  </TabItem>
  <TabItem value="liskl2" label="Lisk L2" default>
    ```solidity
    // SPDX-License-Identifier: MIT
    // compiler version must be greater than or equal to 0.8.20 and less than 0.9.0
    pragma solidity ^0.8.20;

    contract Hello {
      // State variable for the Hello messages
      mapping(address => string) public message;
      // State variable for the message counter
      uint32 public counter = 0;
    }
    ```
  </TabItem>
</Tabs>

### Events
<Tabs>
  <TabItem value="liskl1" label="Lisk L1">
    
      ```typescript
      import { BaseEvent } from 'lisk-sdk';

      export const newHelloEventSchema = {
        $id: '/hello/events/new_hello',
        type: 'object',
        required: ['senderAddress', 'message'],
        properties: {
          senderAddress: {
            dataType: 'bytes',
            fieldNumber: 1,
          },
          message: {
            dataType: 'string',
            fieldNumber: 2,
          },
        },
      };

      export interface NewHelloEventData {
        senderAddress: Buffer;
        message: string;
      }

      export class NewHelloEvent extends BaseEvent<NewHelloEventData> {
        public schema = newHelloEventSchema;
      }
      ```
  </TabItem>
  <TabItem value="liskl2" label="Lisk L2" default>
    ```solidity
    // SPDX-License-Identifier: MIT
    // compiler version must be greater than or equal to 0.8.20 and less than 0.9.0
    pragma solidity ^0.8.20;

    contract Hello {
      // State variable for the Hello messages
      mapping(address => string) public message;
      // State variable for the message counter
      uint32 public counter = 0;
      // Event for new Hello messages
      event NewHello(address indexed sender, string message);

    }
    ```
  </TabItem>
</Tabs>

### Commands
<Tabs>
  <TabItem value="liskl1" label="Lisk L1">
    ```typescript
    /* eslint-disable class-methods-use-this */

    import {
      BaseCommand,
      CommandVerifyContext,
      CommandExecuteContext,
      VerificationResult,
      VerifyStatus,
    } from 'lisk-sdk';
    import { createHelloSchema } from '../schema';
    import { MessageStore } from '../stores/message';
    import { counterKey, CounterStore, CounterStoreData } from '../stores/counter';
    import { ModuleConfig } from '../types';
    import { NewHelloEvent } from '../events/new_hello';

    interface Params {
      message: string;
    }

    export class CreateHelloCommand extends BaseCommand {
      public schema = createHelloSchema;
      private _blacklist!: string[];

      // eslint-disable-next-line @typescript-eslint/require-await
      public async init(config: ModuleConfig): Promise<void> {
        // Set _blacklist to the value of the blacklist defined in the module config
        this._blacklist = config.blacklist;
        // Set the max message length to the value defined in the module config
        this.schema.properties.message.maxLength = config.maxMessageLength;
        // Set the min message length to the value defined in the module config
        this.schema.properties.message.minLength = config.minMessageLength;
      }

      // eslint-disable-next-line @typescript-eslint/require-await
      public async verify(context: CommandVerifyContext<Params>): Promise<VerificationResult> {
        let validation: VerificationResult;
        const wordList = context.params.message.split(" ");
        const found = this._blacklist.filter(value => wordList.includes(value));
        if (found.length > 0) {
          context.logger.info("==== FOUND: Message contains a blacklisted word ====");
          throw new Error(
              `Illegal word in hello message: ${  found.toString()}`
            );
        } else {
          context.logger.info("==== NOT FOUND: Message contains no blacklisted words ====");
          validation = {
            status: VerifyStatus.OK
          };
        }
        return validation;
      }

      public async execute(context: CommandExecuteContext<Params>): Promise<void> {
        // 1. Get account data of the sender of the Hello transaction.
        const { senderAddress } = context.transaction;
        // 2. Get message and counter stores.
        const messageSubstore = this.stores.get(MessageStore);
        const counterSubstore = this.stores.get(CounterStore);

        // 3. Save the Hello message to the message store, using the senderAddress as key, and the message as value.
        await messageSubstore.set(context, senderAddress, {
          message: context.params.message,
        });

        // 3. Get the Hello counter from the counter store.
        let helloCounter: CounterStoreData;
        try {
          helloCounter = await counterSubstore.get(context, counterKey);
        } catch (error) {
          helloCounter = {
            counter: 0,
          }
        }
        // 5. Increment the Hello counter +1.
        helloCounter.counter+=1;

        // 6. Save the Hello counter to the counter store.
        await counterSubstore.set(context, counterKey, helloCounter);

        // 7. Emit a "New Hello" event
        const newHelloEvent = this.events.get(NewHelloEvent);
        newHelloEvent.add(context, {
          senderAddress: context.transaction.senderAddress,
          message: context.params.message
        },[context.transaction.senderAddress]);
      }
    }
    ```
  </TabItem>
  <TabItem value="liskl2" label="Lisk L2" default>
    ```bash
    forge install willitscale/solidity-util
    ```

    ```solidity
    // SPDX-License-Identifier: MIT
    // compiler version must be greater than or equal to 0.8.20 and less than 0.9.0
    pragma solidity ^0.8.20;
    import "lib/solidity-util/lib/Strings.sol";

    contract Hello {
        using Strings for string;

        /** State variables */
        // State variable for the Hello messages
        mapping(address => string) public message;
        // State variable for the message counter
        uint32 public counter = 0;
        // Address of the contract owner
        address public owner;
        // Blacklist of words that are not allowed in the Hello message
        string[] public blacklist = ["word1","word2"];
        // Maximum length of the Hello message
        uint32 public maxLength = 200;
        // Minimum length of the Hello message
        uint32 public minlength = 3;

        constructor() {
            // Set the transaction sender as the owner of the contract.
            owner = msg.sender;
        }

        /** Modifiers */
        // Modifier to check that the caller is the owner of the contract.
        modifier onlyOwner() {
            require(msg.sender == owner, "Not owner");
            _;
        }
        // Modifier to check if the message is valid.
        modifier validMessage(string memory _message) {
            require(_message.length() >= minlength, "Message too short");
            require(_message.length() <= maxLength, "Message too long");
            for (uint i = 0; i < blacklist.length; i++) {
                require(!_message.contains(blacklist[i]), "Message contains blacklisted word");
            }
            _;
        }

        /** Events */
        // Event for new Hello messages
        event NewHello(address indexed sender, string message);

        /** Functions */
        // Function to configure the blacklist
        function setBlacklist(string[] calldata _newBlacklist) public onlyOwner {
            blacklist = _newBlacklist;
        }
        // Function to configure min/max message length
        function setMinMaxMessageLength(uint32 _newMin,uint32 _newMax) public onlyOwner {
            minlength = _newMin;
            maxLength = _newMax;
        }
        // Function to create a new Hello message
        function createHello(string calldata _message) public validMessage(_message) {
            message[msg.sender] = _message;
            counter+=1;
            emit NewHello(msg.sender, _message);
        }
    }
    ```
  </TabItem>
</Tabs>

### Endpoints

<Tabs>
  <TabItem value="liskl1" label="Lisk L1">
  ```typescript
  public async getHelloCounter(ctx: ModuleEndpointContext): Promise<CounterStoreData> {
    const counterSubStore = this.stores.get(CounterStore);

    const helloCounter = await counterSubStore.get(
      ctx,
      counterKey,
    );

    return helloCounter;
  }

  public async getHello(ctx: ModuleEndpointContext): Promise<MessageStoreData> {
    const messageSubStore = this.stores.get(MessageStore);

    const { address } = ctx.params;
    if (typeof address !== 'string') {
      throw new Error('Parameter address must be a string.');
    }
    cryptography.address.validateLisk32Address(address);
    const helloMessage = await messageSubStore.get(
      ctx,
      cryptography.address.getAddressFromLisk32Address(address),
    );
    return helloMessage;
  }
  ```
  </TabItem>
  <TabItem value="liskl2" label="Lisk L2" default>
    ```solidity
    // Function to get the Hello message counter
    function getHelloCounter() public view returns (uint32) {
        return counter;
    }
    // Function to get the Hello message of an address
    function getHello(address _address) public view returns (string) {
        return message[_address];
    }
    ```
  </TabItem>
</Tabs>

### Methods

{/* ## Plugin migration */}